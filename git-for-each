#!/bin/bash

# Run command on each listed git repository, or on all repositories beneath the current directori

. "/data/bin/imports/exit-on-error" || exit 1

usage_print() {
    print_error "Usage: '$0 [-d (debug)] [-q (quiet)] [-a (all) | <repository> ...] -- <command> ...'"
}

usage_exit() {
    usage_print
    exit 2
}

[ $# -ge 3 ] || usage_exit

all=
quiet=
debug=
# Note getopt consumes '--' (if it's present) and returns false, leaving OPTIND pointing at the option after '--'
while getopts ":aqd" flag ; do
    case "$flag" in
        "a" ) all="y" ;;
        "q" ) quiet="y" ;;
        "d" ) debug="y" ;;
        ":" ) print_error "Missing argument to option '$OPTARG'" ; usage_exit ;;
        "?" ) print_error "Unknown commandline option '$OPTARG'" ; usage_exit ;;
        *   ) exit_with_error "Unhandled option '$OPTARG'" ;;
    esac
done
# Consume the options processed by getopt, except the last one, which we need so we can find the '--' delimiting the repos list.
# If getopt stopped without finding '--', we detect this later.
while [ $OPTIND -gt 1 ] && [ "$1" != "--" ] ; do
    shift
    (( OPTIND-- ))
done

[ -n "$debug" ] && echo "Debug mode, not executing commands"

# If not in 'all' mode, everything else up until '--' forms the list of repositories
declare -a repositories
if [ -n "$all" ]; then
    [ -n "$debug" ] && echo "Repos: (all)"
else
    i=0
    while [ $# -gt 0 ] && [ "$1" != "--" ]; do
        [ -n "$debug" ] && echo "Repos: $1"
        repositories[(( i++ ))]="$1"
        shift
    done
    [ $i -eq 0 ] && usage_exit
fi

# Dashes separate command from args / repos list, always required
if [ "$1" = "--" ]; then
    shift
else
    usage_exit
fi

# The rest is the command to run in each repos - must be at least one word.
[ $# -ge 1 ] || usage_exit

if [ -n "$debug" ]; then
    echo "Command:
$@"
    exit 0
fi

# Don't rename these variables, they are meant to be available for use in the target command (under eval)
declare -x FULL_REPOS_DIR
declare -x RELATIVE_REPOS_DIR

rootdir="$PWD"
if [ -n "$all" ]; then
    find . -name ".git" -type d -print0 | sort --zero-terminated | while read -r -d $'\0' gitdir ; do
        FULL_REPOS_DIR="$(readlink -enq "$rootdir/$gitdir/..")"
        RELATIVE_REPOS_DIR="${FULL_REPOS_DIR#$rootdir/}"
        cd "$FULL_REPOS_DIR"
        [ -n "$quiet" ] || echo "$RELATIVE_REPOS_DIR:"
        ( eval "$@" )
        [ -n "$quiet" ] || echo
        :
    done
else
    for (( i=0 ; i < ${#repositories[@]} ; i++ )); do
        cd "$rootdir" # since it may be a relative path
        # Don't rename these variables, they are meant to be available for use in the target command
        FULL_REPOS_DIR="$(readlink -mnq "${repositories[$i]}")"
        RELATIVE_REPOS_DIR="${FULL_REPOS_DIR#$rootdir/}"
        [ -d "$FULL_REPOS_DIR" ] || { print_error "No such directory: '$FULL_REPOS_DIR'" ; usage_exit ; }
        cd "$FULL_REPOS_DIR"
        [ -d ".git" ] || { print_error "Not a git repository: '$FULL_REPOS_DIR/.git' not found" ; usage_exit ; }
        [ -n "$quiet" ] || echo "$RELATIVE_REPOS_DIR:"
        ( eval "$@" )
        [ -n "$quiet" ] || echo
        :
    done
fi
